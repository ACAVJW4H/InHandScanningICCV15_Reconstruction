// Author: Dimitrios Tzionas
//
// source code for the work:
//
// Dimitrios Tzionas and Juergen Gall
// 3D Object Reconstruction from Hand-Object Interactions
// International Conference on Computer Vision (ICCV) 2015
// http://files.is.tue.mpg.de/dtzionas/In-Hand-Scanning


#include <registrator.h>




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////  GLOBAL REGISTRATION !!! //////////////////////////////////////////////////////////////////////////////////////   GLOBAL REGISTRATION !!!
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




void Registrator::myReg_X_TSDF_local( QString INPUT_PATH, QString OUTPUT_PATH, int NUMBBB, bool VIEW_ENABLED, QString input__IMG__PCL, bool shouldPerformTSDF )
{

        ////////////////
        // Visualizer //
        ////////////////

        boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer (new pcl::visualization::PCLVisualizer("TSDF local"));
        viewer->setBackgroundColor( PARAM_BackGround_RRR, PARAM_BackGround_GGG, PARAM_BackGround_BBB );
        viewer->initCameraParameters();
        viewer->resetCameraViewpoint();
        viewer->removeAllPointClouds();

        if (applyHANDs)     myLoadCameraParams( viewer );

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        std::string                              PATH_Aligned_PCL = QString(   OUTPUT_PATH + "___OUT___1___pairwiseAlignment_PCL_VoxelGrid.pcd"   ).toStdString();
        pcl::PointCloud<TYPE_Point_PostPr>::Ptr                     accumAlignedClouds_UNorg_PN( new pcl::PointCloud<TYPE_Point_PostPr> );
        pcl::io::loadPCDFile<TYPE_Point_PostPr>( PATH_Aligned_PCL, *accumAlignedClouds_UNorg_PN );

        TYPE_Point_PostPr                                     pointMIN, pointMAX;
        pcl::getMinMax3D(       *accumAlignedClouds_UNorg_PN, pointMIN, pointMAX );
        Eigen::Vector4f                                       centroid;
        pcl::compute3DCentroid( *accumAlignedClouds_UNorg_PN, centroid );


        Eigen::Matrix4f TSDF_Centroid_Transform;
                        TSDF_Centroid_Transform << 1,0,0,-centroid(0),
                                                   0,1,0,-centroid(1),
                                                   0,0,1,-centroid(2),
                                                   0,0,0,1;

        std::cout <<                                                                                                                           std::endl;
        std::cout << "Registrator::myReg_X_TSDF - Aligned"  << "\t\t" << "PCL  = " << PATH_Aligned_PCL <<                                      std::endl;
        std::cout << "Registrator::myReg_X_TSDF - Aligned"  << "\t\t" << "minX = " << pointMIN.x       << "\t\t" << "maxX = " << pointMAX.x << std::endl;
        std::cout << "Registrator::myReg_X_TSDF - Aligned"  << "\t\t" << "minY = " << pointMIN.y       << "\t\t" << "maxY = " << pointMAX.y << std::endl;
        std::cout << "Registrator::myReg_X_TSDF - Aligned"  << "\t\t" << "minZ = " << pointMIN.z       << "\t\t" << "maxZ = " << pointMAX.z << std::endl;
        std::cout <<                                                                                                                           std::endl;
        std::cout << "Registrator::myReg_X_TSDF - CENTROID" << "\t\t" << centroid(0) << "\t\t" << centroid(1) << "\t\t" << centroid(2)      << std::endl;
        std::cout << "Registrator::myReg_X_TSDF - CENTROID" << "\t\n" << TSDF_Centroid_Transform                                            << std::endl;
        std::cout <<                                                                                                                                              std::endl;
        std::cout << "Registrator::myReg_X_TSDF - Aligned"  << "\t\t" << "minX'= " << pointMIN.x-centroid(0)  << "\t\t" << "maxX'= " << pointMAX.x-centroid(0) << std::endl;
        std::cout << "Registrator::myReg_X_TSDF - Aligned"  << "\t\t" << "minY'= " << pointMIN.y-centroid(1)  << "\t\t" << "maxY'= " << pointMAX.y-centroid(1) << std::endl;
        std::cout << "Registrator::myReg_X_TSDF - Aligned"  << "\t\t" << "minZ'= " << pointMIN.z-centroid(2)  << "\t\t" << "maxZ'= " << pointMAX.z-centroid(2) << std::endl;
        std::cout <<                                                                                                                                              std::endl;


        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        cpu_tsdf::TSDFVolumeOctree::Ptr tsdf;
        tsdf.reset( new cpu_tsdf::TSDFVolumeOctree );
        /////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////
        // make sure the parameters of the TSDF are appropriate:
        // - size
        // - resolution
        // - truncation distance
        // - min/max sensor distance
        /////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////

                                tsdf->setGridSize(              PARAM_TSDF_GridSize,      PARAM_TSDF_GridSize,      PARAM_TSDF_GridSize   );  // meters
                                tsdf->setResolution(            PARAM_TSDF_Resolution,    PARAM_TSDF_Resolution,    PARAM_TSDF_Resolution );  // 1024 2048 3072 4096
                                tsdf->setImageSize(             PARAM_TSDF_Img_Width,     PARAM_TSDF_Img_Height );
                                tsdf->setCameraIntrinsics(      PARAM_CAM_Intrinsics_fx,  PARAM_CAM_Intrinsics_fy,  PARAM_CAM_Intrinsics_px, PARAM_CAM_Intrinsics_py );
                                tsdf->setSensorDistanceBounds(  PARAM_TSDF_SensorDistBound_MIN, PARAM_TSDF_SensorDistBound_MAX );
                                tsdf->setIntegrateColor(        PARAM_TSDF_Color );
        if (PARAM_TSDF_Color)   tsdf->setColorMode("RGB");
                                tsdf->setDepthTruncationLimits( PARAM_TSDF_DepthTrunc_MaxPOS, PARAM_TSDF_DepthTrunc_MaxNEG );
                                tsdf->setNumRandomSplts (       PARAM_TSDF_NumRandomSplts);
                                tsdf->setWeightTruncationLimit( PARAM_TSDF_MaxWeightTruncLimit );
                                tsdf->setMaxVoxelSize(          PARAM_TSDF_MaxVoxelSize,
                                                                PARAM_TSDF_MaxVoxelSize,
                                                                PARAM_TSDF_MaxVoxelSize);

        //////////////////////////////////////////////
        float                          minDB, maxDB;
        tsdf->getSensorDistanceBounds( minDB, maxDB );
        //////////////////////////////////////////////
        float              gSizX, gSizY, gSizZ;
        tsdf->getGridSize( gSizX, gSizY, gSizZ);
        //////////////////////////////////////////////
        double                     fx, fy, px, py;
        tsdf->getCameraIntrinsics( fx, fy, px, py);
        //////////////////////////////////////////////
        int                  resX, resY, resZ;
        tsdf->getResolution( resX, resY, resZ);
        ///////////////////////////////////////////////////
        float wTruncLim = tsdf->getWeightTruncationLimit();
        ///////////////////////////////////////////////////
        float                           maxPos, maxNeg;
        tsdf->getDepthTruncationLimits( maxPos, maxNeg );
        /////////////////////////////////////////////////
        int NumRandomSplits = tsdf->getNumRandomSplits();
        /////////////////////////////////////////////////

        //////////////
        tsdf->reset();
        //////////////


        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        std::cout << "\n\n"                  << std::endl;
        std::cout << "NUMBBB  = " << NUMBBB  << std::endl;
        std::cout << "\n\n"                  << std::endl;


        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        //////////////////////////////////////////////////////////////
        ////  READ Pairwise Aligned ORGgg_PN PointClouds + Poses  ////
        //////////////////////////////////////////////////////////////


        for (int iii=0; iii<NUMBBB; iii++)
        {

                /////////////////////////////////////////////////
                int fileID = PARAM_INDEX_List.frames[iii].fileID;
                /////////////////////////////////////////////////

                pcl::PointCloud<TYPE_Point_Sensor>::Ptr CURR_cloud_P__PREE( new pcl::PointCloud<TYPE_Point_Sensor> );
                pcl::PointCloud<TYPE_Point_PostPr>::Ptr CURR_cloud_PN_PREE( new pcl::PointCloud<TYPE_Point_PostPr> );
                pcl::PointCloud<TYPE_Point_PostPr>::Ptr CURR_cloud_PN_POST( new pcl::PointCloud<TYPE_Point_PostPr> ( PARAM_TSDF_Img_Width, PARAM_TSDF_Img_Height ));

                QString CURR_fileLocTransf = OUTPUT_PATH + "trans_locTransf/" + QString::number( fileID ).rightJustified(fileNamePADDING,'0',false) + ".transf";   QFile qFileLocTransf( CURR_fileLocTransf );      if  (qFileLocTransf.exists() == false)                                 {   std::cout << std::endl << CURR_fileLocTransf.toStdString() << " DOES NOT EXIST !!!!!" << std::endl << std::endl;     exit(1);  }
                QString CURR_filePCD_ORGgg = INPUT_PATH  + "pcl/"             + QString::number( fileID ).rightJustified(fileNamePADDING,'0',false) + ".pcd";      QFile qFilePCD_ORGgg( CURR_filePCD_ORGgg );      if ((qFilePCD_ORGgg.exists() == false) && (input__IMG__PCL == "PCL"))  {   std::cout << std::endl << CURR_filePCD_ORGgg.toStdString() << " DOES NOT EXIST !!!!!" << std::endl << std::endl;     exit(1);  }

                Eigen::Affine3d aff_trans;

                Eigen::Matrix4f cloud_LOC_Transf;

                /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                {

                        if (input__IMG__PCL == "PCL")
                        {

                                std::cout << CURR_filePCD_ORGgg.toStdString() << std::endl;

                                pcl::io::loadPCDFile( CURR_filePCD_ORGgg.toStdString(), *CURR_cloud_P__PREE );

                        }
                        else if (input__IMG__PCL == "IMG")
                        {

                                readIMG_getPCL( INPUT_PATH, fileID, CURR_cloud_P__PREE, true );

                        }

                        cloud_LOC_Transf = txt_2_transf( CURR_fileLocTransf );

                        //////////////////////////////////////////////////////////////
                        //////////////////////////////////////////////////////////////
                        cloud_LOC_Transf = TSDF_Centroid_Transform * cloud_LOC_Transf;   // move @ the Center of the TSDF !!! in order to have a smaller TSDF !!!
                        //////////////////////////////////////////////////////////////
                        //////////////////////////////////////////////////////////////


                }


                ///////////////////////////////////////////////////
                ///////////////////////////////////////////////////
                potentialUnitChange_PCL_m2mm( CURR_cloud_P__PREE );
                ///////////////////////////////////////////////////
                ///////////////////////////////////////////////////


                /////////////////////////////////////////////////////
                /////////////////////////////////////////////////////
                aff_trans.matrix() = cloud_LOC_Transf.cast<double>();
                /////////////////////////////////////////////////////
                /////////////////////////////////////////////////////


                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        Normals - FAKE !!! in order to kick small parts that remain after skinn color rejection !!!
                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                my_Normal_Estimator( CURR_cloud_P__PREE,
                                     CURR_cloud_PN_PREE, syntheticORrealistic, true );

                std::vector<int>                                                             dummyIndicesNAN;
                pcl::removeNaNFromPointCloud(        *CURR_cloud_PN_PREE, *CURR_cloud_PN_PREE, dummyIndicesNAN);
                pcl::removeNaNNormalsFromPointCloud( *CURR_cloud_PN_PREE, *CURR_cloud_PN_PREE, dummyIndicesNAN);


                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        OUTLIER REMOVAL
                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                if (syntheticORrealistic.contains("realistic")  && PARAM_KILL_PASS==false)
                {
                    // Create the filtering object
                    pcl::PassThrough<TYPE_Point_PostPr>                     pass;
                                                                            pass.setFilterFieldName( "z" );
                                                                            pass.setFilterLimits( PARAM_PASS_FILTER_ZZZ_min, PARAM_PASS_FILTER_ZZZ_max );
                                                                            pass.setKeepOrganized( true );
                                                                            pass.setInputCloud(  CURR_cloud_PN_PREE);
                                                                            pass.filter(        *CURR_cloud_PN_PREE);
                                                                            ///////////////////////////////////////////////
                                                                            pass.setFilterFieldName( "y" );
                                                                            pass.setFilterLimits( PARAM_PASS_FILTER_YYY_min, PARAM_PASS_FILTER_YYY_max );
                                                                            pass.setKeepOrganized( true );
                                                                            pass.setInputCloud(  CURR_cloud_PN_PREE);
                                                                            pass.filter(        *CURR_cloud_PN_PREE);
                                                                            ///////////////////////////////////////////////
                                                                            pass.setFilterFieldName( "x" );
                                                                            pass.setFilterLimits( PARAM_PASS_FILTER_XXX_min, PARAM_PASS_FILTER_XXX_max );
                                                                            pass.setKeepOrganized( true );
                                                                            pass.setInputCloud(  CURR_cloud_PN_PREE);
                                                                            pass.filter(        *CURR_cloud_PN_PREE);
                                                                            ///////////////////////////////////////////////
                }


                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                for (size_t j = 0; j < CURR_cloud_PN_POST->size (); j++)     CURR_cloud_PN_POST->at (j).z = std::numeric_limits<float>::quiet_NaN ();
                for (size_t j = 0; j < CURR_cloud_PN_PREE->size (); j++)
                {
                    const TYPE_Point_PostPr &PT_PREE = CURR_cloud_PN_PREE->at (j);
                    int                               uuu, vvv;
                    if (reprojectPoint(      PT_PREE, uuu, vvv))
                    {
                        TYPE_Point_PostPr                                       &PT_POST = (*CURR_cloud_PN_POST)( uuu, vvv );
                        if (pcl_isnan (PT_POST.z) || (PT_POST.z > PT_PREE.z))    PT_POST = PT_PREE;
                    }
                }
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                ///////////////////////////////////////////////////////////////////////////////////////////
                ///////////////////////////////////////////////////////////////////////////////////////////
                tsdf->integrateCloud( *CURR_cloud_PN_POST, pcl::PointCloud<pcl::Normal>(), aff_trans );
                ///////////////////////////////////////////////////////////////////////////////////////////
                ///////////////////////////////////////////////////////////////////////////////////////////

                /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                pcl::transformPointCloud( *CURR_cloud_P__PREE, *CURR_cloud_P__PREE, cloud_LOC_Transf ); // only for visualization
                pcl::transformPointCloud( *CURR_cloud_PN_PREE, *CURR_cloud_PN_PREE, cloud_LOC_Transf ); // only for visualization

                std::string cloud_STR = QString( "cloud_" + QString::number( fileID ) ).toStdString();

                pcl::visualization::PointCloudColorHandlerRGBField<TYPE_Point_PostPr>visColor( CURR_cloud_PN_PREE );

                viewer->addPointCloud<TYPE_Point_PostPr>(CURR_cloud_PN_PREE,visColor,cloud_STR);

                viewer->setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE,1,cloud_STR);

                //////////////////////
                viewer->resetCamera();
                viewer->spinOnce();
                //////////////////////

        }


        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        if (shouldPerformTSDF)
        {

                ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                //// Mesh with marching cubes  ////////////////////////////////////////////////////////////////////////////////////////
                ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                cpu_tsdf::MarchingCubesTSDFOctree mc;
                                                  mc.setColorByRGB(           PARAM_TSDF_Color);
                                                  mc.setColorByConfidence(    PARAM_TSDF_ColorSetByConf);
                                                  mc.setMinWeight(            PARAM_TSDF_Min_Weight_MC);
                                                  mc.setInputTSDF( tsdf );    pcl::PolygonMesh mesh;
                                                  mc.reconstruct(                              mesh);


                std::cout <<                                                                    std::endl;
                std::cout <<                                                                    std::endl;
                std::cout << "mc.ISO_level      " << "\t\t" << mc.getIsoLevel()              << std::endl;
                std::cout << "mc.PercExtendGrid " << "\t\t" << mc.getPercentageExtendGrid()  << std::endl;
                std::cout << "mc.Min_Weight_MC  " << "\t\t" << PARAM_TSDF_Min_Weight_MC      << std::endl;

                ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                std::vector<Eigen::Vector3i>   occupVoxIDs;
                tsdf->getOccupiedVoxelIndices( occupVoxIDs);
                std::cout << "SnsrDstBnds    " << "\t\t" << minDB << "\t\t" << maxDB                                      << std::endl;
                std::cout << "gird size      " << "\t\t" << gSizX << "\t\t" << gSizY << "\t\t" << gSizZ                   << std::endl;
                std::cout << "fx fy px py    " << "\t\t" <<    fx << "\t\t" <<    fy << "\t\t" <<    px << "\t\t" <<   py << std::endl;
                std::cout << "resX resY resZ " << "\t\t" <<  resX << "\t\t" <<  resY << "\t\t" <<  resZ                   << std::endl;
                std::cout << "wTruncLim      " << "\t\t" << wTruncLim                                                     << std::endl;
                std::cout << "depthTruncLim  " << "\t\t" << maxPos<< "\t\t" <<  maxNeg                                    << std::endl;
                std::cout << "NumRandomSplits" << "\t\t" << NumRandomSplits                                               << std::endl;
                std::cout << "tsdf->isEmpty()" << "\t\t" << tsdf->isEmpty()                                               << std::endl;
                std::cout << "occupiedVoxelsN" << "\t\t" << occupVoxIDs.size()                                            << std::endl;
                ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                QString pathSave = OUTPUT_PATH + "___OUT___2___pairwiseAlignment_TSDF.ply";

                pcl::io::savePLYFile( pathSave.toStdString(), mesh );
                std::cout <<          pathSave.toStdString() << std::endl;


                viewer->removeAllPointClouds();
                viewer->removeAllShapes();
                viewer->addPolygonMesh( mesh );

        }


        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        //////////////////////
        viewer->resetCamera();
        viewer->spinOnce();
        //////////////////////

        if (VIEW_ENABLED == true)
        {
            while (!viewer->wasStopped())
            {
                viewer->spinOnce();
                boost::this_thread::sleep(boost::posix_time::microseconds(100000));
            }
        }


}



